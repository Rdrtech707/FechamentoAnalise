# ================= app.py =================
# Arquivo: app.py

import pandas as pd
import logging
import sys
from datetime import datetime
from config import MDB_FILE, MDB_PASSWORD
from modules.access_db import get_connection
from modules.extractors import get_ordens, get_contas, get_fcaixa
from modules.processors import process_recebimentos
from modules.exporters import export_to_excel


def setup_logging():
    """Configura o sistema de logging"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('app.log', encoding='utf-8'),
            logging.StreamHandler(sys.stdout)
        ]
    )
    return logging.getLogger(__name__)


def validate_input(year: str, month: str) -> tuple[str, str]:
    """
    Valida e formata os inputs de ano e mês
    
    Args:
        year: Ano informado pelo usuário
        month: Mês informado pelo usuário
        
    Returns:
        tuple: (ano_validado, mes_validado)
        
    Raises:
        ValueError: Se os valores não forem válidos
    """
    # Remove espaços e valida se são números
    year = year.strip()
    month = month.strip()
    
    if not year.isdigit() or not month.isdigit():
        raise ValueError("Ano e mês devem ser números válidos")
    
    year_int = int(year)
    month_int = int(month)
    
    # Validação de ano (entre 2000 e 2100)
    if year_int < 2000 or year_int > 2100:
        raise ValueError("Ano deve estar entre 2000 e 2100")
    
    # Validação de mês (entre 1 e 12)
    if month_int < 1 or month_int > 12:
        raise ValueError("Mês deve estar entre 1 e 12")
    
    # Formata mês com zero à esquerda
    month_formatted = f"{month_int:02d}"
    
    return year, month_formatted


def main():
    """Função principal da aplicação"""
    logger = setup_logging()
    
    try:
        logger.info("Iniciando aplicação de processamento de recebimentos")
        
        # Pergunta mês e ano ao usuário
        year = input("Informe o ano (YYYY): ").strip()
        month = input("Informe o mês (MM): ").strip()
        
        # Valida inputs
        try:
            year_validated, month_validated = validate_input(year, month)
            periodo = f"{year_validated}-{month_validated}"
            logger.info(f"Período selecionado: {periodo}")
        except ValueError as e:
            logger.error(f"Erro na validação de input: {e}")
            print(f"❌ Erro: {e}")
            return
        
        # Conecta e extrai dados
        logger.info("Conectando ao banco de dados...")
        try:
            conn = get_connection(MDB_FILE, MDB_PASSWORD)
            logger.info("Conexão com banco de dados estabelecida com sucesso")
        except Exception as e:
            logger.error(f"Erro ao conectar ao banco de dados: {e}")
            print(f"❌ Erro ao conectar ao banco de dados: {e}")
            print("Verifique se o arquivo .mdb existe e a senha está correta")
            return
        
        # Extrai dados
        logger.info("Extraindo dados das tabelas...")
        try:
            ordens_df = get_ordens(conn)
            contas_df = get_contas(conn)
            fcaixa_df = get_fcaixa(conn)
            logger.info(f"Dados extraídos: {len(ordens_df)} ordens, {len(contas_df)} contas, {len(fcaixa_df)} registros FCAIXA")
        except Exception as e:
            logger.error(f"Erro ao extrair dados: {e}")
            print(f"❌ Erro ao extrair dados do banco: {e}")
            return
        finally:
            conn.close()
            logger.info("Conexão com banco de dados fechada")

        # Processa recebimentos
        logger.info("Processando recebimentos...")
        try:
            recibos = process_recebimentos(ordens_df, contas_df, fcaixa_df, periodo)
            logger.info(f"Processamento concluído: {len(recibos)} registros processados")
        except Exception as e:
            logger.error(f"Erro no processamento: {e}")
            print(f"❌ Erro no processamento dos dados: {e}")
            return

        # Remove hora, mantendo apenas a data
        try:
            recibos['DATA PGTO'] = pd.to_datetime(recibos['DATA PGTO']).dt.date
            recibos['DATA ENCERRAMENTO'] = pd.to_datetime(recibos['DATA ENCERRAMENTO']).dt.date
        except Exception as e:
            logger.warning(f"Erro ao converter datas: {e}")

        # Reordena colunas
        column_order = [
            'N° OS', 'DATA PGTO', 'VALOR TOTAL', 'VALOR MÃO DE OBRA',
            'VALOR PEÇAS', 'DESCONTO', 'VALOR PAGO', 'DEVEDOR', 'CARTÃO', 'DINHEIRO',
            'PIX', 'TROCO', 'VEÍCULO (PLACA)', 'CÓDIGO CLIENTE', 'DATA ENCERRAMENTO'
        ]
        
        # Verifica se todas as colunas existem
        missing_columns = [col for col in column_order if col not in recibos.columns]
        if missing_columns:
            logger.warning(f"Colunas não encontradas: {missing_columns}")
            # Remove colunas que não existem da lista de ordenação
            column_order = [col for col in column_order if col in recibos.columns]
        
        recibos = recibos[column_order]

        # Filtra pelo período desejado baseado em DATA PGTO
        try:
            valid = recibos.dropna(subset=['DATA PGTO']).copy()
            valid['MES'] = valid['DATA PGTO'].astype(str).str.slice(0, 7)
            
            if periodo in valid['MES'].unique():
                df_periodo = valid[valid['MES'] == periodo].drop(columns='MES')
                logger.info(f"Encontrados {len(df_periodo)} registros para o período {periodo}")
                
                # Exporta para Excel
                try:
                    export_to_excel({periodo: df_periodo}, output_dir='data/recebimentos')
                    logger.info(f"Arquivo Excel gerado com sucesso")
                    print(f"✅ Arquivo gerado: data/recebimentos/Recebimentos_{periodo}.xlsx")
                except Exception as e:
                    logger.error(f"Erro ao exportar para Excel: {e}")
                    print(f"❌ Erro ao gerar arquivo Excel: {e}")
                    return
            else:
                logger.warning(f"Nenhum registro encontrado para o período {periodo}")
                print(f"⚠️ Nenhum registro encontrado para o período {periodo}")
        except Exception as e:
            logger.error(f"Erro ao filtrar por período: {e}")
            print(f"❌ Erro ao filtrar dados por período: {e}")
            return
        
        logger.info("Processamento concluído com sucesso")
        print("✅ Processamento concluído com sucesso!")
        
    except KeyboardInterrupt:
        logger.info("Aplicação interrompida pelo usuário")
        print("\n⚠️ Aplicação interrompida pelo usuário")
    except Exception as e:
        logger.error(f"Erro inesperado: {e}", exc_info=True)
        print(f"❌ Erro inesperado: {e}")
        print("Consulte o arquivo app.log para mais detalhes")


if __name__ == '__main__':
    main()


# ================= config.py =================
# Arquivo: config.py

import os
from dotenv import load_dotenv

# Carrega variáveis de ambiente do arquivo .env
load_dotenv()

# Caminho para o arquivo .mdb e senha
MDB_FILE = os.getenv("MDB_FILE")
MDB_PASSWORD = os.getenv("MDB_PASSWORD")


# ================= modules/access_db.py =================
# Arquivo: modules/access_db.py

import pyodbc


def get_connection(mdb_file: str, password: str):
    """
    Conecta ao .mdb/.accdb usando ODBC.
    """
    conn_str = (
        r"DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};"
        rf"DBQ={mdb_file};"
        rf"PWD={password};"
    )
    return pyodbc.connect(conn_str)


# ================= modules/extractors.py =================
# Arquivo: modules/extractors.py

import pandas as pd


def get_ordens(conn) -> pd.DataFrame:
    """
    Extrai dados da tabela ORDEMS, excluindo serviços com SITUACAO = 11.
    """
    query = """
    SELECT
        CODIGO,
        SAIDA,
        V_MAO,
        V_PECAS,
        V_DESLOCA,
        V_TERCEIRO,
        V_OUTROS,
        APARELHO,
        MODELO,
        SITUACAO
    FROM ORDEMS
    """
    df = pd.read_sql_query(query, conn, parse_dates=["SAIDA"])
    # Exclui ordens com SITUACAO == 11
    df = df[df['SITUACAO'] != 11].copy()
    # Remove coluna SITUACAO
    return df.drop(columns=['SITUACAO'])


def get_contas(conn) -> pd.DataFrame:
    """
    Extrai dados da tabela CONTAS:
    - CODIGO, TIPO, COD_CLIENTE, PAGO, OBSERVACAO,
      VALOR, REFERENCIA, ECF_DINHEIRO, ECF_CARTAO,
      ECF_TROCO, DATA_PGTO
    """
    query = """
    SELECT
        CODIGO,
        TIPO,
        COD_CLIENTE,
        PAGO,
        OBSERVACAO,
        VALOR,
        REFERENCIA,
        ECF_DINHEIRO,
        ECF_CARTAO,
        ECF_TROCO,
        DATA_PGTO
    FROM CONTAS
    """
    df = pd.read_sql_query(query, conn, parse_dates=["DATA_PGTO"])
    return df


def get_fcaixa(conn) -> pd.DataFrame:
    """
    Extrai dados da tabela FCAIXA:
    - RECEITA, COD_CONTA, FORMA
    """
    query = """
    SELECT
        RECEITA,
        COD_CONTA,
        FORMA
    FROM FCAIXA
    """
    df = pd.read_sql_query(query, conn)
    return df


# ================= modules/processors.py =================
# Arquivo: modules/processors.py
import pandas as pd


def process_recebimentos(
    ordens_df: pd.DataFrame,
    contas_df: pd.DataFrame,
    fcaixa_df: pd.DataFrame,
    periodo: str = None
) -> pd.DataFrame:
    """
    Monta a tabela consolidada de recebimentos:
    Colunas: N° OS, DATA ENCERRAMENTO, VALOR TOTAL, VALOR MÃO DE OBRA,
             VALOR PEÇAS, DESCONTO, VEÍCULO (PLACA), CÓDIGO CLIENTE,
             VALOR PAGO, DEVEDOR, CARTÃO, DINHEIRO, PIX, TROCO
    
    Args:
        periodo: Formato 'YYYY-MM' para filtrar DATA_PGTO (ex: '2024-01')
    """
    # --- Prepara ordens ---
    ordens = ordens_df.copy()
    ordens['VALOR TOTAL'] = ordens[['V_MAO','V_PECAS','V_DESLOCA','V_TERCEIRO','V_OUTROS']].sum(axis=1)
    ordens['VEÍCULO (PLACA)'] = ordens['APARELHO'] + ' (' + ordens['MODELO'] + ')'
    ordens_proc = ordens.rename(columns={
        'CODIGO': 'N° OS',
        'SAIDA': 'DATA ENCERRAMENTO',
        'V_MAO': 'VALOR MÃO DE OBRA',
        'V_PECAS': 'VALOR PEÇAS',
        'V_OUTROS': 'DESCONTO'
    })[[
        'N° OS','DATA ENCERRAMENTO','VALOR TOTAL',
        'VALOR MÃO DE OBRA','VALOR PEÇAS','DESCONTO','VEÍCULO (PLACA)'
    ]]

    # --- Prepara FCAIXA: extrai código numérico e soma receitas por forma ---
    fcaixa = fcaixa_df.copy()
    fcaixa['COD_CONTA'] = (
        fcaixa['COD_CONTA']
        .astype(str)
        .str.extract(r'R(\d+)', expand=False)
        .fillna('0')
        .astype(int)
    )
    pix_receita = fcaixa[fcaixa['FORMA'] == 5].groupby('COD_CONTA')['RECEITA'].sum()
    dinheiro_receita = fcaixa[fcaixa['FORMA'] == 0].groupby('COD_CONTA')['RECEITA'].sum()

    # --- Prepara CONTAS para VALOR PAGO (PAGO = 'S') ---
    contas_pagas = contas_df.copy()
    contas_pagas['CODIGO'] = pd.to_numeric(contas_pagas['CODIGO'], errors='coerce').fillna(0).astype(int)
    contas_pagas['OS'] = contas_pagas['REFERENCIA'].astype(str).str.extract(r'^O(\d+)$', expand=False)
    contas_pagas = contas_pagas.dropna(subset=['OS']).copy()
    contas_pagas['OS'] = contas_pagas['OS'].astype(int)
    
    # --- Filtra apenas contas pagas (PAGO = 'S') ---
    contas_pagas = contas_pagas[contas_pagas['PAGO'] == 'S'].copy()
    
    # --- Filtra por DATA_PGTO do período especificado ---
    if periodo:
        contas_pagas['DATA_PGTO'] = pd.to_datetime(contas_pagas['DATA_PGTO'], errors='coerce')
        contas_pagas['MES_PGTO'] = contas_pagas['DATA_PGTO'].dt.strftime('%Y-%m')
        contas_pagas = contas_pagas[contas_pagas['MES_PGTO'] == periodo].copy()
        contas_pagas = contas_pagas.drop(columns=['MES_PGTO'])
    
    contas_pagas = contas_pagas.merge(pix_receita.rename('RECEITA_PIX'),
                          left_on='CODIGO', right_index=True, how='left')
    contas_pagas = contas_pagas.merge(dinheiro_receita.rename('RECEITA_DINHEIRO'),
                          left_on='CODIGO', right_index=True, how='left')
    contas_pagas = contas_pagas.fillna(0)

    # --- Cálculo de DINHEIRO e PIX conforme regra correta ---
    contas_pagas['DINHEIRO'] = contas_pagas['ECF_DINHEIRO'] - contas_pagas['RECEITA_PIX']
    contas_pagas['PIX'] = contas_pagas['ECF_DINHEIRO'] - contas_pagas['RECEITA_DINHEIRO']

    # --- Garante que DATA_PGTO seja datetime e agrega por OS ---
    contas_pagas['DATA_PGTO'] = pd.to_datetime(contas_pagas['DATA_PGTO'], errors='coerce')
    agg_pagas = contas_pagas.groupby('OS').agg({
        'COD_CLIENTE': 'first',
        'VALOR': 'sum',
        'ECF_CARTAO': 'sum',
        'DINHEIRO': 'sum',
        'PIX': 'sum',
        'ECF_TROCO': 'sum',
        'DATA_PGTO': 'max'
    }).rename(columns={
        'COD_CLIENTE': 'CÓDIGO CLIENTE',
        'VALOR': 'VALOR PAGO',
        'ECF_CARTAO': 'CARTÃO',
        'ECF_TROCO': 'TROCO',
        'DATA_PGTO': 'DATA PGTO'
    })

    # --- Prepara CONTAS para DEVEDOR (PAGO = 'N') ---
    contas_devidas = contas_df.copy()
    contas_devidas['CODIGO'] = pd.to_numeric(contas_devidas['CODIGO'], errors='coerce').fillna(0).astype(int)
    contas_devidas['OS'] = contas_devidas['REFERENCIA'].astype(str).str.extract(r'^O(\d+)$', expand=False)
    contas_devidas = contas_devidas.dropna(subset=['OS']).copy()
    contas_devidas['OS'] = contas_devidas['OS'].astype(int)
    
    # --- Filtra apenas contas devidas (PAGO = 'N') ---
    contas_devidas = contas_devidas[contas_devidas['PAGO'] == 'N'].copy()
    
    # --- Agrega DEVEDOR por OS ---
    agg_devidas = contas_devidas.groupby('OS')['VALOR'].sum().rename('DEVEDOR')

    # --- Merge final com as ordens ---
    final = ordens_proc.merge(agg_pagas, left_on='N° OS', right_index=True, how='left')
    final = final.merge(agg_devidas, left_on='N° OS', right_index=True, how='left')
    
    # --- Preenche valores nulos com 0 ---
    final['DEVEDOR'] = final['DEVEDOR'].fillna(0)
    
    return final


# ================= modules/exporters.py =================
# Arquivo: modules/exporters.py

import os
import pandas as pd
from openpyxl.utils import get_column_letter
from openpyxl.styles import Alignment


def export_to_excel(dataframes_by_month: dict, output_dir: str):
    """
    Salva cada DataFrame em planilhas Excel separadas por mês,
    ajustando automaticamente a largura das colunas e formatando
    colunas numéricas em estilo contábil com duas casas decimais.

    - dataframes_by_month: {"YYYY-MM": pd.DataFrame}
    - output_dir: pasta onde salvar os arquivos
    """
    os.makedirs(output_dir, exist_ok=True)

    contabeis = [
        "VALOR TOTAL", "VALOR MÃO DE OBRA", "VALOR PEÇAS",
        "DESCONTO", "VALOR PAGO", "DEVEDOR", "CARTÃO", "DINHEIRO",
        "PIX", "TROCO"
    ]

    for month, df in dataframes_by_month.items():
        filepath = os.path.join(output_dir, f"Recebimentos_{month}.xlsx")
        with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
            sheet_name = month
            df.to_excel(writer, sheet_name=sheet_name, index=False)
            ws = writer.sheets[sheet_name]

            for idx, col in enumerate(df.columns, start=1):
                # Ajusta largura de cada coluna com base no conteúdo
                max_length = max(
                    df[col].astype(str).map(len).max(),
                    len(col)
                ) + 2
                ws.column_dimensions[get_column_letter(idx)].width = max_length

                # Aplica formatação contábil para colunas numéricas
                if col in contabeis:
                    for cell in ws[get_column_letter(idx)][1:]:
                        cell.number_format = 'R$ #,##0.00'
                        cell.alignment = Alignment(horizontal='left')


# ================= utils/helpers.py =================
# Arquivo: utils/helpers.py

# (arquivo vazio)


# ================= requirements.txt =================
pyodbc
pandas
python-dotenv
openpyxl 